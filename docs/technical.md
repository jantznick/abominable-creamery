# Abominable Creamery - Technical Documentation

## 1. Overview

This document outlines the technical stack, architecture, and operational flow of the Abominable Creamery website project. The goal is to provide a comprehensive guide for developers maintaining and extending the codebase.

The project is a web application for an ice cream shop, built using Node.js, React, and TypeScript, featuring server-side rendering (SSR). Key upcoming features include user authentication, persistent order storage with guest checkout, and admin order viewing.

## 2. Tech Stack

### 2.1. Core Technologies

*   **Runtime Environment:** Node.js
*   **Primary Language:** TypeScript
*   **Package Manager:** npm
*   **Database:** PostgreSQL

### 2.2. Backend

*   **Framework:** Express.js - Used to handle HTTP requests, serve static assets, perform server-side rendering, and provide API endpoints.
*   **Database ORM:** Prisma (`prisma`, `@prisma/client`) - Manages database interactions, migrations, and type safety with PostgreSQL.
    *   **Database Driver:** `pg`
*   **Authentication:**
    *   **Password Hashing:** `bcrypt`
    *   **Session Management:** `express-session` with `connect-pg-simple` for persistent PostgreSQL session storage.
*   **Server-Side Rendering:** Implemented using `react-dom/server` (`renderToString`) and `react-router-dom/server` (`StaticRouter`) within an Express route handler (`serverRender.tsx`).

### 2.3. Frontend

*   **Framework:** React v18 (`react`, `react-dom`)
*   **Routing:** React Router v6 (`react-router-dom`) - Handles client-side navigation and defines application routes (`src/routes/index.tsx`).
*   **State Management:** React Context API
    *   `CartContext`: Manages shopping cart state (persisted via `localStorage`).
    *   `AuthContext` (Planned): Manages user authentication state.
*   **Styling:** Tailwind CSS v3 (`tailwindcss`) - Utility-first CSS framework for styling components. Base configuration is in `tailwind.config.js`, input CSS is `src/styles/style.css`, outputting to `public/css/style.css`.
*   **UI Components:** Organized within `src/components/` (reusable) and `src/pages/` (route-level).
*   **Utility:** `classnames`, `fuzzysort`.

### 2.4. Build & Development Tools

*   **Bundler:** Webpack v5 (`webpack`, `webpack-cli`, `webpack.DefinePlugin`) - Bundles JavaScript/TypeScript code, CSS, and other assets for the browser (`webpack.config.js`). Injects environment variables like `STRIPE_PUBLISHABLE_KEY` for frontend use.
*   **Transpiler:** Babel (`babel-loader`, `babel-preset-react-app`, `.babelrc`) - Used by Webpack to transpile modern JavaScript/JSX features.
*   **TypeScript Compiler:** `tsc` (`typescript`, `tsconfig.json`) - Compiles TypeScript to JavaScript.
*   **Development Server:** `nodemon` - Monitors server files.
*   **CSS Watcher:** `tailwindcss --watch` - Monitors CSS files.

### 2.5. Integrations

*   **Payments:** Stripe (`stripe`, `@stripe/react-stripe-js`, `@stripe/stripe-js`) - Integrated for payment processing via Payment Intents and Payment Element.

## 3. Project Structure

*   `/.babelrc`: Babel configuration file.
*   `/.env`: Environment variables (should not be committed). Define database connection strings and Stripe keys here.
*   `/.gitignore`: Specifies intentionally untracked files that Git should ignore.
*   `/built/`: Contains the output of the TypeScript/Webpack build for the server code (`server.js`).
*   `/dist/` / `/static-build/`: Build output directories (confirm usage via `webpack.config.js` if needed).
*   `/node_modules/`: Contains installed npm packages.
*   `/package.json`: Defines project metadata, dependencies, and npm scripts.
*   `/package-lock.json`: Records exact versions of dependencies.
*   `/prisma/`:
    *   `schema.prisma`: Defines database models (User, Order, OrderItem, enums) and relations.
    *   `/migrations/`: Contains database migration files generated by `prisma migrate`.
*   `/public/`: Static assets served directly by Express (CSS, client-side JS bundles, images).
    *   `/css/style.css`: Compiled Tailwind output.
    *   `/js/bundle.js`: Client-side JavaScript bundle from Webpack.
*   `/src/`: Main application source code.
    *   `/components/`: Reusable React components (e.g., Header, Footer).
    *   `/pages/`: Route-level React components (e.g., Home, Flavors, Cart).
    *   `/routes/`: Frontend route definitions (`index.tsx`).
    *   `/styles/`: Source CSS/Tailwind files (`style.css`).
    *   `/utils/`: Utility functions and potentially shared data/content (`content.ts`).
    *   `/App.tsx`: Root React component (currently simple).
*   `/serverRender.tsx`: Express server setup and server-side rendering logic (entry point for server build).
*   `/clientRender.tsx`: Client-side React hydration logic (entry point for the Webpack client bundle).
*   `/tailwind.config.js`: Tailwind CSS configuration.
*   `/tsconfig.json`: TypeScript configuration.
*   `/webpack.config.js`: Webpack configuration.
*   `/tasks/`: Contains markdown files outlining feature implementation plans.
*   `/src/context/`: Contains React Context providers (e.g., `CartContext.tsx`, `AuthContext.tsx`).

## 4. Operational Flow

### 4.1. Build Process

*   **Development (`npm start`):** Runs Webpack in watch mode (`build-app`), Tailwind CSS in watch mode (`build-watch-css`), and starts the server with Nodemon (`run-server` executing `built/server.js`).
*   **Production (`npm run build-server-prod`):** Builds Tailwind CSS once and runs Webpack in production mode to create optimized bundles. This is also triggered automatically after `npm install` due to the `postinstall` script.
*   **Output:** Webpack bundles client-side JavaScript into `public/js/bundle.js` and server-side code into `built/server.js`. Tailwind compiles CSS to `public/css/style.css`.

### 4.2. Request Lifecycle (Server-Side Rendering)

1.  Client requests a page URL.
2.  Express server (`serverRender.tsx` -> `built/server.js`) catches the request via `app.get('*')`.
3.  The handler uses `renderToString` with `StaticRouter` (using the request URL) and `AppRoutes` to generate the initial HTML for the requested route.
4.  The server sends the full HTML document, including the rendered React content within `<div id="root">`, links to CSS (`public/css/style.css`), and the client-side JS bundle (`public/js/bundle.js`).
5.  Browser displays the static HTML.
6.  Browser downloads and executes `bundle.js`.
7.  `clientRender.tsx` uses `ReactDOM.hydrateRoot` to attach React to the existing server-rendered DOM (`<div id="root">`), making the page interactive.
8.  Subsequent navigation is handled client-side by React Router.

### 4.3. API Endpoints (Planned & Existing)

*   API routes are defined within the Express application (likely prefixed with `/api/`).
*   **Authentication (`/api/auth/`):**
    *   `POST /signup`: Register new user.
    *   `POST /login`: Authenticate user, create session.
    *   `POST /logout`: Destroy session.
    *   `GET /me`: Get current logged-in user details.
*   **Payment (`/`):**
    *   `POST /create-payment-intent`: Creates a Stripe Payment Intent.
*   **Orders (`/api/orders/`):**
    *   `POST /`: Create a new order (post-payment). Associates with logged-in user if available.
    *   `GET /my`: Get orders for the current logged-in user.
*   **Admin (`/api/admin/`):**
    *   `GET /orders`: Get all orders (requires ADMIN role).

### 4.4. State Management

*   **Cart:** `CartContext` manages items, persisted in `localStorage`.
*   **Authentication:** `AuthContext` (to be implemented) will manage user login status and user data globally on the client-side.

### 4.5. Checkout & Order Flow

1.  User adds items to cart (`CartContext`).
2.  User proceeds to checkout (`/checkout`).
3.  Checkout page presents accordion: Contact -> Shipping -> Payment.
4.  User fills contact/shipping info. Guest checkout is allowed.
5.  On reaching the Payment section, a request is sent to `/create-payment-intent` with the final calculated total (including shipping/tax).
6.  Backend creates Stripe PaymentIntent, returns `clientSecret`.
7.  Frontend renders Stripe Payment Element using the `clientSecret`.
8.  User submits payment via Stripe Element.
9.  Stripe processes payment and redirects user to `/order-confirmation`.
10. `OrderConfirmation` page retrieves PaymentIntent status from Stripe using URL params.
11. **If payment `succeeded`:**
    *   Frontend sends a `POST` request to `/api/orders` with checkout details (items, shipping, contact info).
    *   Backend saves the `Order` and `OrderItem` data to the database (associating with `userId` if user was logged in).
    *   Frontend clears the cart (`CartContext`) and displays a success message.
12. **If payment fails/pending:** Display appropriate status/error message.

## 5. Key Areas & Conventions

*   **Server Entry Point:** `serverRender.tsx` (compiled to `built/server.js`).
*   **Client Entry Point:** `clientRender.tsx` (bundled into `public/js/bundle.js`).
*   **Routing:** Client-side routes defined in `src/routes/index.tsx` using `react-router-dom`. SSR handled via catch-all in `serverRender.tsx`.
*   **Styling:** Primarily via Tailwind CSS utility classes applied directly in components. Base styles in `src/styles/style.css`.
*   **Data Fetching:** To be implemented via backend API endpoints using Express and Prisma.
*   **Environment Variables:** Managed via `.env` file. Requires `DATABASE_URL`, `STRIPE_SECRET_KEY`, `STRIPE_PUBLISHABLE_KEY`, `SESSION_SECRET`.
*   **Database Schema:** Defined in `prisma/schema.prisma`.
*   **Migrations:** Managed via `npx prisma migrate dev`.
*   **Authentication:** Session-based using `express-session` and `connect-pg-simple`.
*   **Authorization:** Simple role check (e.g., `req.session.user.role === 'ADMIN'`) in specific API route middleware.

## 6. Setup & Running Locally

1.  Clone the repository.
2.  Create a `.env` file based on `.env.example` (if it exists) or add the following:
    *   `DATABASE_URL="postgresql://user:password@host:port/database"` (Replace with your PostgreSQL connection string)
    *   `STRIPE_SECRET_KEY=sk_test_...`
    *   `STRIPE_PUBLISHABLE_KEY=pk_test_...`
    *   `SESSION_SECRET=your_strong_random_session_secret` (Generate a strong random string)
3.  Install dependencies: `npm install`
4.  **Ensure PostgreSQL is running** and accessible via the `DATABASE_URL`.
5.  Run Prisma migrations: `npx prisma migrate dev` (Creates DB if needed, applies migrations)
6.  **(Optional) Seed Database:** `npx prisma db seed` (if seed script is configured).
7.  Start the development server: `npm start`
8.  Access the application at `http://localhost:3000`.

## 7. Stripe Product Integration

### 7.1 Overview

Instead of relying on a static list of products defined in `src/utils/content.ts`, the application fetches product information directly from Stripe. This allows for dynamic updating of product details, pricing, and availability via the Stripe Dashboard without requiring code changes and deployments.

### 7.2 Data Flow

1.  **Stripe Setup:** Ice cream flavors are configured as `Product` objects in the Stripe Dashboard. Each product has associated metadata (e.g., `simpleName`, `hasDairy`, `hasEgg`), images, and a default `Price` object. Products must be marked as "Active".
2.  **Server-Side Fetching:** During the Server-Side Rendering (SSR) process in `serverRender.tsx`, a utility function (`src/server/utils/stripeProducts.ts` - TBC) uses the Stripe Node.js library (`stripe.products.list`) with the `STRIPE_SECRET_KEY` to fetch all active products and their default prices.
3.  **Data Transformation:** The fetched Stripe data is transformed into the application's internal `Flavor` data structure.
4.  **SSR Injection:** The transformed product list is passed down to the React application during server rendering, likely via props or a dedicated `ProductContext`.
5.  **Frontend Consumption:** Frontend components (e.g., `Flavors.tsx`, `ProductDetail.tsx`) access the product data through props or the context provider, eliminating the need for client-side fetching for initial display.
6.  **Cart & Checkout:** The `CartContext` stores items using Stripe Price IDs. The `/create-payment-intent` backend endpoint verifies prices using the Stripe API based on the Price IDs provided from the cart, ensuring accurate payment amounts.

### 7.3 Key Implementation Points

*   **Server Utility:** A dedicated module handles fetching and mapping Stripe products (`src/server/utils/stripeProducts.ts` - TBC).
*   **SSR Integration:** Logic within `serverRender.tsx` orchestrates the fetching and injection of product data.
*   **Frontend Adaptation:** Components are refactored to consume data via props/context instead of static import.
*   **Stripe Metadata:** Consistency between the application's data needs and the metadata fields defined in Stripe Products is crucial.
*   **Price Management:** Pricing is managed directly via Stripe `Price` objects. The application uses Price IDs for cart and checkout operations. 